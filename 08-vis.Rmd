# Visualization with drake {#vis}

```{r vissetup, echo = FALSE}
suppressMessages(suppressWarnings(library(drake)))
knitr::opts_chunk$set(
  collapse = TRUE,
  error = TRUE,
  warning = TRUE
)
pkgconfig::set_config("drake::strings_in_dots" = "literals")
```

`Drake` has powerful visuals to help you plan your project. You can generate an interactive workflow network with `vis_drake_graph()`. Then click, drag, hover, zoom, and pan. Use either the mouse or the green buttons near the bottom.

## Dependency reactivity

Initially, your entire project is out of date.

```{r graphoutdated}
library(drake)
load_mtcars_example() # Get the code with drake_example("mtcars").
config <- drake_config(my_plan)
vis_drake_graph(config) # Same as drake_graph()
```

After `make()`, the whole project is all caught up.

```{r graphmake}
config <- make(my_plan, jobs = 4, verbose = FALSE)
vis_drake_graph(config)
```


But when you change a dependency, some targets are out of date until the next `make(my_plan)`.

```{r reg2graphvisual}
reg2 <- function(d){
  d$x3 <- d$x ^ 3
  lm(y ~ x3, data = d)
}
vis_drake_graph(config)
```

The `vis_drake_graph()` and `render_drake_graph()` are based on the [`visNetwork`](http://datastorm-open.github.io/visNetwork/) package. [`visNetwork`](http://datastorm-open.github.io/visNetwork/) have layers of customization options, which you can read about [here](http://datastorm-open.github.io/visNetwork/).

## Subgraphs

Graphs can grow enormous for serious projects, so there are multiple ways to focus on a manageable subgraph. The most brute-force way is to just pick a manual `subset` of nodes. However, with the `subset` argument, `vis_drake_graph()` may drop intermediate nodes and edges.

```{r subsetgraph}
vis_drake_graph(
  config,
  subset = c("regression2_small", file_store("report.md"))
)
```

The rest of the subgraph functionality preserves connectedness. Use `targets_only` to ignore the imports.

```{r targetsonly}
vis_drake_graph(config, targets_only = TRUE)
```

Similarly, you can just show downstream nodes.

```{r fromout}
vis_drake_graph(config, from = c("regression2_small", "regression2_large"))
```

Or upstream ones.

```{r fromin}
vis_drake_graph(config, from = "small", mode = "in")
```

In fact, let us just take a small neighborhood around a target in both directions.


```{r fromall}
vis_drake_graph(config, from = "small", mode = "all", order = 1)
```

## Control the legend.

To remove superfluous information from the legend, set the `full_legend` argument to `FALSE`.

```{r smalllegend}
vis_drake_graph(config, full_legend = FALSE)
```

To remove the legend altogether, set the `ncol_legend` argument to `0`.

```{r nolegend}
vis_drake_graph(config, ncol_legend = 0)
```

## Clusters

With the `group` and `clusters` arguments to `vis_drake_graph()` and `drake_graph_info()`, you can condense nodes into clusters. This is handy for workflows with lots of targets. Take the schools scenario from the [workflow plan guide](#plans). Our plan was generated with `evaluate_plan(trace = TRUE)`, so it has wildcard columns that group nodes into natural clusters already. You can manually add such columns if you wish.

```{r tracevisgraph1}
plan_template <- drake_plan(
  school = get_school_data("school__"),
  credits = check_credit_hours(all_schools__),
  students = check_students(all_schools__),
  grads = check_graduations(all_schools__),
  public_funds = check_public_funding(public_schools__)
)
plan <- evaluate_plan(
  plan = plan_template,
  rules = list(
    school__ = c("A", "B", "C"),
    all_schools__ =  c("school_A", "school_B", "school_C"),
    public_schools__ = c("school_A", "school_B")
  ),
  trace = TRUE
)
plan
```

Ordinarily, the workflow graph gives a separate node to each individual import object or target.

```{r tracevisgraphhide1, echo = FALSE}
check_credit_hours <- check_students <- check_graduations <-
  check_public_funding <- get_school_data <- function(){}
```

```{r wholeschoolsvis}
config <- drake_config(plan)
vis_drake_graph(config)
```

For large projects with hundreds of nodes, this can get quite cumbersome. But here, we can choose a wildcard column (or any other column in the plan, even custom columns) to condense nodes into natural clusters. For the `group` argument of `vis_drake_graph()`, choose the name of a column in `plan` or a column you know will be in `drake_graph_info(config)$nodes`. Then for `clusters`, choose the values in your `group` column that correspond to nodes you want to bunch together. The new graph is not as cumbersome.


```{r tracevisgraph2}
config <- drake_config(plan)
vis_drake_graph(
  config,
  group = "all_schools__",
  clusters = c("school_A", "school_B", "school_C")
)
```

As I mentioned, you can group on any column in `drake_graph_info(config)$nodes`. Let's return to the `mtcars` project for demonstration.

```{r traceviscars1}
config <- drake_config(my_plan)
vis_drake_graph(config)
```

Let's condense all the imports into one node and all the up-to-date targets into another. That way, the outdated targets stand out.

```{r traceviscars2}
vis_drake_graph(
  config,
  group = "status",
  clusters = c("imported", "up to date")
)
```

## Static graphs

For small projects and minimal reproducible examples, it is often useful to construct static (non-interactive) graphs. Use `static_drake_graph()` to produce a [`ggplot2`](https://ggplot2.tidyverse.org/)/[`ggraph`](https://github.com/thomasp85/ggraph) version of your graph, which you can then augment with further layers, plot in your console, or save with `ggsave()`.

```{r static}
plan <- drake_plan(data = get_data(), model = data, plot = data)
get_data <- function(){}
config <- drake_config(plan)
static_drake_graph(config)
```

## Node and edge data frames

`drake_graph_info()` is used in both `vis_drake_graph()` and `static_drake_graph()` to obtain data frames of nodes and edges before rendering. The functions `render_drake_graph()` and `render_static_drake_graph()` accept this graph info object directly, which could speed up the construction of new visuals.

```{r drakegraphinfo34908234}
str(drake_graph_info(config))
```

```{r viscleanup}
drake::clean(destroy = TRUE)
unlink("report.Rmd")
```
