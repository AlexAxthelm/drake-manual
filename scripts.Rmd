# `drake` and script-based workflows {#scripts}

```{r, message = FALSE, warning = FALSE, echo = FALSE}
knitr::opts_knit$set(root.dir = fs::dir_create(tempfile()))
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r, message = FALSE, warning = FALSE, echo = FALSE}
library(drake)
library(glue)
library(purrr)
library(rlang)
library(tidyverse)
invisible(drake_example("script-based-workflows", overwrite = TRUE))
tmp <- file.copy(
  list.files("script-based-workflows/R/",
             pattern = "*.R", full.names = TRUE),
  ".",
  recursive = TRUE)
tmp <- file.copy("script-based-workflows/raw_data.xlsx", ".")
tmp <- file.copy("script-based-workflows/report.Rmd", ".")
dir.create("data")
```
## Function-oriented workflows

`drake` was built around the idea that writing functions for data analysis allows
the author to break down complicated ideas into manageable pieces.

```{r}
# R/functions.R
get_data <- function(file){
  readxl::read_excel(file)
}

munge_data <- function(raw_data){
  raw_data %>% 
    mutate(Species = forcats::fct_inorder(Species))
}

fit_model <- function(munged_data){
  lm(Sepal.Width ~ Petal.Width + Species, munged_data)
}
```

By turning the steps of processing into functions like `get_data()`, `munge_data()`, 
and `fit_model()`, they become special shorthand that make the plan easier to
read and understand exactly what is being done.


```{r}
# R/plan.R
plan <- drake_plan(
  raw_data = get_data(file_in("raw_data.xlsx")),
  munged_data = munge_data(raw_data),
  model = fit_model(munged_data)
)
```

This function-oriented approach is elegant, powerful, testable, scalable, and 
maintainable. However, it can be challenging to convert pre-existing traditional
script-based analyses to function-oriented `drake`-powered workflows. This
chapter describes a stopgap that quickly retrofits `drake` and functions onto
existing projects without needing to change the original underlying scripts with
minimal overhead.

## Traditional and Legacy Workflows

The common approach to express data analysis tasks is in numbered scripts.

```
01_data.R
02_munge.R
03_histogram.R
04_regression.R
05_report.R
```

The numeric prefixes are used to indicate the order in which these scripts
should be run.

```{r,eval=FALSE}

# run_everything.R
source("01_data.R")
source("02_munge.R")
source("03_histogram.R")
source("04_regression.R")
# Calls rmarkdown::render on report.Rmd
source("05_report.R")
```

## Overcoming Technical Debt

`code_to_function()` can create a `drake`-plan-ready from each numbered script.

```{r}

# R/functions.R
load_data <- code_to_function("01_data.R")
munge_data <- code_to_function("02_munge.R")
make_histogram <- code_to_function("03_histogram.R")
do_regression <- code_to_function("04_regression.R")
generate_report <- code_to_function("05_report.R")
```

The newly created script-functions contain all the executable code from each of
scripts that they are based off of.

```{r}
print(load_data)
```

## Dependencies

An important aspect of `drake` plans is the capability to track the dependencies 
of each function and only rerun the parts of the plan that have updated, either
in code or input. In `drake`, a target's dependencies are the things it needs
in order to build. Dependencies can include functions, files, and other targets
upstream. Any time the prior step updates, then any down-stream steps that rely 
on its outputs need to be updated.

To take advantage of this feature, we will need to first generate a plan from 
loading the data to generating a histogram. In a normal non-`drake` workflow,
the format might some something along the lines of the following.

```{r eval=FALSE}

source("01_data.R")
source("02_munge.R")
source("03_histogram.R")

```

Instead, we can use the functions of the scripts that were generated via
`code_to_function()` and generate a `drake` plan.

```{r}

simple_plan <- drake_plan(
  data        = load_data(),
  munged_data = munge_data(),
  hist        = make_histogram()
)

```

This looks good and dandy, but right now `drake` has no idea which part to run 
first, and which targets depend on the outputs of the next!

```{r}

simple_config <- drake_config(simple_plan)
vis_drake_graph(simple_config)

```


## Building the connections

If we know which scripts need to be run before others, we use `targets` to 
indicate to `drake` the order each function need to be evaluated by passing 
targets as arguments in functions. 

In the case described above, the final script, "03_histogram.R", generates a 
plot of a histogram using the data generated from "02_munge.R", which relies on
"01_data.R" to load the data. "01_data.R" is the first script that needs to be
evaluated and does not rely on any other inputs. 

We can apply the same logic by passing the targets of the `code_to_function()`
generated functions as arguments in the dependent script-functions.

```{r}

simple_plan <- drake_plan(
  data     = load_data(),
  munged_data = munge_data(data),
  hist     = make_histogram(munged_data)
)
```

```{r echo=FALSE}

simple_config <- drake_config(simple_plan)
vis_drake_graph(simple_config)

```


## Putting it all together

Using the first example of a make script in this chapter as the framework, the
new script that evaluates the entire workflow would look as follows.

```{r eval=FALSE}

# R/make.R

source("R/functions.R")

# Create drake Plan
script_based_plan <- drake_plan(
  data        = load_data(),
  munged_data = munge_data(data),
  hist        = make_histogram(munged_data),
  fit         = do_regression(munged_data),
  report      = generate_report(hist, fit)
)

make(script_based_plan)

```

By converting the scripts to functions and passing targets of the prior 
dependencies, `drake` is able track dependencies and when make.R is rerun,
only the updated scripts will be rerun.

```{r echo=FALSE,message=FALSE}

# Create Drake Plan
script_based_plan <- drake_plan(
  data        = load_data(),
  munged_data = munge_data(data),
  hist        = make_histogram(munged_data),
  fit         = do_regression(munged_data),
  report      = generate_report(hist, fit)
)

make(script_based_plan)
```

```{r}

script_based_config <- drake_config(script_based_plan)
vis_drake_graph(script_based_config, targets_only = TRUE)
```


Any time a script is updated, either `functions.R` can be sourced again to 
update the representative function, or the specific `code_to_function()` line 
can be rerun. `drake` can see that the function is updated and when `make()` 
is called, it will rerun the updated function and all down-stream functions that
rely on the output. 

For example, if in "03_histogram.R" were to be updated so the `binwidth` of the 
histogram was now `0.5` as opposed to the original `0.25`, for `drake` to detect
that the script has been updated, execute `code_to_function()` on the script.

```{r echo=FALSE}
writeLines(
  c("munged_data <- readRDS(\"data/munged_data.RDS\")",
    "gg <- munged_data %>%",
    "ggplot() +",
    "geom_histogram(",
    "  aes(",
    "    x = Petal.Width,",
    "    fill = Species",
    "    ),",
    "  binwidth = 0.5) +",
    "  theme_gray(20)",
    "ggsave(",
    "filename = \"data/Petal_Width_vs_Species.PNG\",",
    "plot = gg",
    ")",
    "saveRDS(gg, \"data/Petal_Width_vs_Species.RDS\")"),
  "03_histogram.R"
  )

```

```{r}
# "03_historgram.R" has been updated with a new bin-width of 0.5. Re-running 
# code_to_function()` to generate the the new function is required for
# `drake` to recognize that the script has been updated. 
make_histogram <- code_to_function("03_histogram.R")
```

`drake` has now marked both `hist` and `report` as outdated, as the function 
that generates `hist` has been updated, and since `generate_report()` depends on
`hist`, it also has been outdated.

```{r echo=FALSE,message=FALSE}
outdated_targets<-outdated(script_based_config)
#needs to be run, for some reason `drake` is not recognizing the update when compiling
vis_drake_graph(script_based_config, targets_only = TRUE)
```

When `make()` is now called, `drake` will rerun only `make_histogram()` to update
`hist`, and `generate_report()` since it depends on `hist`.

```{r}
make(script_based_plan)
```

The dependency graph is now all up to date!

```{r, echo=FALSE}
vis_drake_graph(script_based_config, targets_only = TRUE)
```


## `drake` and scripts

Hopefully this chapter gave some insight on how to use the `code_to_function()`
functionality available in `drake`. `code_to_function()`is a quick and dirty way
to retrofit `drake` to an existing script-based project. _This approach should
only be taken when re-factoring the workflow into functions is determined to be
unfeasible._ `code_to_function()` was developed to overcome the issue that a
number of preexisting data science workflows consist of imperative scripts that 
are numbered in their order of execution and have a naive make script that 
executes every single script when it is run without regard to updates. `drake`
overcomes this problem of repeated work.

All this being said, `drake` still assumes you write *functions* as opposed to 
scripts to help organize thoughts and improve portability and readability. When 
feasible, it is suggested to re-work existing workflows into factors. There is 
currently a package available on called
[`Rclean`](https://github.com/provtools/rclean) that can help with re-factoring 
scripts into functions. 
