# Triggers: decision rules for building targets {#triggers}

```{r setup_triggers, include = FALSE}
suppressMessages(suppressWarnings(library(cranlogs)))
suppressMessages(suppressWarnings(library(curl)))
suppressMessages(suppressWarnings(library(drake)))
suppressMessages(suppressWarnings(library(dplyr)))
suppressMessages(suppressWarnings(library(ggplot2)))
suppressMessages(suppressWarnings(library(httr)))
suppressMessages(suppressWarnings(library(knitr)))
suppressMessages(suppressWarnings(library(magrittr)))
suppressMessages(suppressWarnings(library(R.utils)))
suppressMessages(suppressWarnings(library(rvest)))
pkgconfig::set_config("drake::strings_in_dots" = "literals")
clean(destroy = TRUE, verbose = FALSE)
unlink(c("Makefile", "report.Rmd", "shell.sh", "STDIN.o*", "Thumbs.db"))
knitr::opts_chunk$set(
  collapse = TRUE,
  error = TRUE,
  warning = TRUE
)
dat <- system.file(
  file.path("examples", "main", "raw_data.xlsx"),
  package = "drake",
  mustWork = TRUE
)
tmp <- file.copy(from = dat, to = "raw_data.xlsx")
rmd <- system.file(
  file.path("examples", "main", "report.Rmd"),
  package = "drake",
  mustWork = TRUE
)
tmp <- file.copy(from = rmd, to = "report.Rmd")
```

When you call `make()`, `drake` tries to skip as many targets as possible. If it thinks a command will output the same value as last time, it does not bother running it. In other words, `drake` is lazy, and laziness saves you time.

## What are triggers?

To figure out whether it can skip a target, `drake` goes through an intricate checklist of **triggers**:

1. The "missing" trigger: do we already have the target's value from a previous `make()`, or is it missing from the cache?
2. The "condition" trigger: user-defined (details later).
3. The "command" trigger: did the command in the workflow plan data frame change since the last `make()`?
4. The "depend" trigger: did any non-file dependencies change since the last `make()`? These could be
    - other targets,
    - imported objects,
    - imported functions,
    - any dependencies of imported functions,
    - any dependencies of dependencies of imported functions, and so on.
5. The "file" trigger: did any file inputs or file outputs change since the last `make()`?
6. The "change" trigger: user-defined (details later).

If *any* of these triggers detects something wrong or different about the target or its dependencies, `drake` runs the command to rebuidl the target.

## Customization

With the exception of the "missing" trigger, 

## The "command" trigger

## The "depend" trigger

## The "file" trigger

## The "condition" trigger

## The "change" trigger

```{r endofline_triggers, echo = FALSE}
clean(destroy = TRUE, verbose = FALSE)
unlink(c("report.Rmd", "raw_data.xlsx", "STDIN.o*", "Thumbs.db"))
```
