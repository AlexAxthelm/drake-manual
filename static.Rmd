# Static branching {#static}

```{r, message = FALSE, warning = FALSE, echo = FALSE}
knitr::opts_knit$set(root.dir = fs::dir_create(tempfile()))
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r, message = FALSE, warning = FALSE, echo = FALSE}
library(drake)
library(glue)
library(purrr)
library(rlang)
library(tidyverse)
invisible(drake_example("main", overwrite = TRUE))
invisible(file.copy("main/raw_data.xlsx", ".", overwrite = TRUE))
invisible(file.copy("main/report.Rmd", ".", overwrite = TRUE))
tmp <- suppressWarnings(drake_plan(x = 1, y = 2))
```

Static branching helps us write large plans compactly. Instead of typing out every single target by hand, we use a special shorthand to declare entire batches of similar targets. Without static branching, plans like this one become cumbersome.

```{r, eval = FALSE}
# Without static branching:

drake_plan(
  data = get_data(),
  analysis_fast_1_main = main(data, mean = 1, tuning = "fast"),
  analysis_slow_1_main = main(data, mean = 1, tuning = "slow"),
  analysis_fast_2_main = main(data, mean = 2, tuning = "fast"),
  analysis_slow_2_main = main(data, mean = 2, tuning = "slow"),
  analysis_fast_3_main = main(data, mean = 3, tuning = "fast"),
  analysis_slow_3_main = main(data, mean = 3, tuning = "slow"),
  analysis_fast_4_main = main(data, mean = 4, tuning = "fast"),
  analysis_slow_4_main = main(data, mean = 4, tuning = "slow"),
  analysis_fast_1_altv = altv(data, mean = 1, tuning = "fast"),
  analysis_slow_1_altv = altv(data, mean = 1, tuning = "slow"),
  analysis_fast_2_altv = altv(data, mean = 2, tuning = "fast"),
  analysis_slow_2_altv = altv(data, mean = 2, tuning = "slow"),
  analysis_fast_3_altv = altv(data, mean = 3, tuning = "fast"),
  analysis_slow_3_altv = altv(data, mean = 3, tuning = "slow"),
  analysis_fast_4_altv = altv(data, mean = 4, tuning = "fast"),
  analysis_slow_4_altv = altv(data, mean = 4, tuning = "slow"),
  summary_analysis_fast_1_main = summarize_model(analysis_fast_1_main),
  summary_analysis_slow_1_main = summarize_model(analysis_slow_1_main),
  summary_analysis_fast_2_main = summarize_model(analysis_fast_2_main),
  summary_analysis_slow_2_main = summarize_model(analysis_slow_2_main),
  summary_analysis_fast_3_main = summarize_model(analysis_fast_3_main),
  summary_analysis_slow_3_main = summarize_model(analysis_slow_3_main),
  summary_analysis_fast_4_main = summarize_model(analysis_fast_4_main),
  summary_analysis_slow_4_main = summarize_model(analysis_slow_4_main),
  summary_analysis_fast_1_altv = summarize_model(analysis_fast_1_altv),
  summary_analysis_slow_1_altv = summarize_model(analysis_slow_1_altv),
  summary_analysis_fast_2_altv = summarize_model(analysis_fast_2_altv),
  summary_analysis_slow_2_altv = summarize_model(analysis_slow_2_altv),
  summary_analysis_fast_3_altv = summarize_model(analysis_fast_3_altv),
  summary_analysis_slow_3_altv = summarize_model(analysis_slow_3_altv),
  summary_analysis_fast_4_altv = summarize_model(analysis_fast_4_altv),
  summary_analysis_slow_4_altv = summarize_model(analysis_slow_4_altv),
  model_summary_altv = dplyr::bind_rows(
    summary_analysis_fast_1_altv,
    summary_analysis_slow_1_altv,
    summary_analysis_fast_2_altv,
    summary_analysis_slow_2_altv,
    summary_analysis_fast_3_altv,
    summary_analysis_slow_3_altv,
    summary_analysis_fast_4_altv,
    summary_analysis_slow_4_altv
  ),
  model_summary_main = dplyr::bind_rows(
    summary_analysis_fast_1_main,
    summary_analysis_slow_1_main,
    summary_analysis_fast_2_main,
    summary_analysis_slow_2_main,
    summary_analysis_fast_3_main,
    summary_analysis_slow_3_main,
    summary_analysis_fast_4_main,
    summary_analysis_slow_4_main
  )
)
```

Static branching makes the plan easier to write and understand.


```{r}
# With static branching:

model_functions <- rlang::syms(c("main", "altv"))

plan <- drake_plan(
  data = get_data(),
  analysis = target(
    model_function(data, mean = mean_value, tuning = tuning_setting),
    transform = cross(
      tuning_setting = c("fast", "slow"),
      mean_value = c(1, 2, 3, 4),
      model_function = !!model_functions
    )
  ),
  summary = target(
    summarize_model(analysis),
    transform = map(analysis)
  ),
  model_summary = target(
    dplyr::bind_rows(summary),
    transform = combine(summary, .by = model_function)
  )
)

plan # a quick and dirty alternative to vis_drake_graph()
```

Always check the graph to make sure the plan makes sense.

```{r}
plot(plan)
```


If the graph is too complicated to look at or too slow to load, downsize the plan with `max_expand`. Then, when you are done debugging and testing, remove `max_expand` to scale back up to the full plan.

```{r}
plan <- drake_plan(
  max_expand = 2,
  data = get_data(),
  analysis = target(
    model_function(data, mean = mean_value, tuning = tuning_setting),
    transform = cross(
      tuning_setting = c("fast", "slow"),
      mean_value = c(1, 2, 3, 4),
      model_function = !!model_functions
    )
  ),
  summary = target(
    summarize_model(analysis),
    transform = map(analysis)
  ),
  model_summary = target(
    dplyr::bind_rows(summary),
    transform = combine(summary, .by = model_function)
  )
)

# Click and drag the nodes in the graph to improve the view.
plot(plan)
```


### The types of transformations

`drake` supports four types of transformations: `map()`, `cross()`, `split()` (unsupported in `drake` <= 7.3.0), and `combine()`. These are not actual functions, but you can treat them as functions when you use them in `drake_plan()`. Each transformation takes after a function from the [Tidyverse](https://www.tidyverse.org/).

| `drake`     | Tidyverse analogue          |
|-------------|-----------------------------|
| `map()`     | `pmap()` from `purrr`       |
| `cross()`   | `crossing()` from `tidyr`   |
| `split()`   | `group_map()`  from `dplyr` |
| `combine()` | `summarize()` from `dplyr`  |

#### `map()`

`map()` creates a new target for each row in a grid.

```{r}
drake_plan(
  x = target(
    simulate_data(center, scale),
    transform = map(center = c(2, 1, 0), scale = c(3, 2, 1))
  )
)
```

You can supply your own custom grid using the `.data` argument. Note the use of `!!` below.

```{r}
my_grid <- tibble(
  sim_function = c("rnorm", "rt", "rcauchy"),
  title = c("Normal", "Student t", "Cauchy")
)
my_grid$sim_function <- rlang::syms(my_grid$sim_function)

drake_plan(
  x = target(
    simulate_data(sim_function, title, center, scale),
    transform = map(
      center = c(2, 1, 0),
      scale = c(3, 2, 1),
      .data = !!my_grid,
      # In `.id`, you can select one or more grouping variables
      # for pretty target names.
      # Set to FALSE to use short numeric suffixes.
      .id = sim_function # Try `.id = c(sim_function, center)` yourself.
    )
  )
)
```

#### Special considerations in `map()`

`map()` column-binds variables together to create a grid. The lengths of those variables need to be conformable just as with `data.frame()`.

```{r, error = TRUE}
drake_plan(
  x = target(
    simulate_data(center, scale),
    transform = map(center = c(2, 1, 0), scale = c(3, 2))
  )
)
```

Sometimes, the results are sensible when grouping variable lengths are multiples of each other, but be careful.

```{r}
drake_plan(
  x = target(
    simulate_data(center, scale),
    transform = map(center = c(2, 1, 0), scale = 4)
  )
)
```

Things get tricker when `drake` reuses grouping variables from previous transformations. For example, below, each `x_*` target has an associated `center` value. So if you write `transform = map(x)`, then `center` goes along for the ride.

```{r}
drake_plan(
  x = target(
    simulate_data(center),
    transform = map(center = c(1, 2))
  ),
  y = target(
    process_data(x, center),
    transform = map(x)
  ),
  trace = TRUE # Adds extra columns for the grouping variables.
)
```

But if other targets have `centers`'s of their own, `drake_plan()` may not know what to do with them.

```{r}
drake_plan(
  w = target(
    simulate_data(center),
    transform = map(center = c(3, 4))
  ),
  x = target(
    simulate_data_2(center),
    transform = map(center = c(1, 2))
  ),
  y = target(
    process_data(w, x, center),
    transform = map(w, x)
  ),
  trace = TRUE
)
```

The problems is that there are 4 values of `center` and only two `x_*` targets (and two `y_*` targets). Even if you explicitly supply `center` to the transformation, `map()` only takes the first two values.

```{r}
drake_plan(
  w = target(
    simulate_data(center),
    transform = map(center = c(3, 4))
  ),
  x = target(
    simulate_data_2(center),
    transform = map(center = c(1, 2))
  ),
  y = target(
    process_data(w, x, center),
    transform = map(w, x, center)
  ),
  trace = TRUE
)
```

So please inspect the plan before you run it with `make()`. Once you have a `drake_config()` object, `vis_drake_graph()` and `deps_target()` can help.

#### `cross()`

`cross()` creates a new target for each combination of argument values.

```{r}
drake_plan(
  x = target(
    simulate_data(nrow, ncol),
    transform = cross(nrow = c(1, 2, 3), ncol = c(4, 5))
  )
)
```


#### `split()`

`split()` is not supported in `drake` 7.3.0 and below. It should reach the next CRAN release in June 2019.

The `split()` transformation distributes a dataset as uniformly as possible across multiple targets.

```{r, split1}
plan <- drake_plan(
  large_data = get_data(),
  slice_analysis = target(
    large_data %>%
      analyze(),
    transform = split(large_data, slices = 4)
  ),
  results = target(
    dplyr::bind_rows(slice_analysis),
    transform = combine(slice_analysis)
  )
)

plan
```

```{r}
config <- drake_config(plan)
vis_drake_graph(config)
```

Here, `drake_slice()` takes a single subset of the data at runtime. 

```{r}
dataset <- tibble::as_tibble(iris)
dim(dataset)

drake_slice(dataset, slices = 50, index = 1)

drake_slice(dataset, slices = 50, index = 2)

drake_slice(dataset, slices = 3, index = 1, margin = 2)
```

`drake_slice()` supports data frames, matrices, and arbitrary arrays, and you can subset on any margin (rows, columns, etc). Even better, you can split up ordinary vectors and lists. Instead of taking slices of the actual dataset, you can split up a set of indices. Combined with [high-performance computing](#hpc), this should help you avoid loading an entire big data file into memory on a single compute node.

```{r}
plan <- drake_plan(
  all_rows = file_in("huge.csv") %>%
    number_of_rows() %>%
    seq_len(),
  rows = target(
    all_rows,
    transform = split(all_rows, slices = 3)
  ),
  analysis = target(
    read_rows( # custom function
      file = file_in("huge.csv"),
      rows = rows
    ) %>%
      analyze_data(),
    transform = map(rows, .id = rows_index) # an internal trick
  )
)

drake_plan_source(plan)
```


#### `combine()`

In `combine()`, you can insert multiple targets into individual commands. The closest comparison is the unquote-splice operator `!!!` from the Tidyverse.

```{r}
plan <- drake_plan(
  data = target(
    sim_data(mean = x, sd = y),
    transform = map(x = c(1, 2), y = c(3, 4))
  ),
  larger = target(
    bind_rows(data, .id = "id") %>%
      arrange(sd) %>%
      head(n = 400),
    transform = combine(data)
  )
)

plan

drake_plan_source(plan)

config <- drake_config(plan)
vis_drake_graph(config)
```

You can different groups of targets in the same command.

```{r}
plan <- drake_plan(
  data_group1 = target(
    sim_data(mean = x, sd = y),
    transform = map(x = c(1, 2), y = c(3, 4))
  ),
  data_group2 = target(
    pull_data(url),
    transform = map(url = c("example1.com", "example2.com"))
  ),
  larger = target(
    bind_rows(data_group1, data_group2, .id = "id") %>%
      arrange(sd) %>%
      head(n = 400),
    transform = combine(data_group1, data_group2)
  )
)

drake_plan_source(plan)
```

And as with `group_by()` from `dplyr`, you can create a separate aggregate for each combination of levels of the arguments. Just pass a symbol or vector of symbols to the optional `.by` argument of `combine()`.

```{r}
plan <- drake_plan(
  data = target(
    sim_data(mean = x, sd = y, skew = z),
    transform = cross(x = c(1, 2), y = c(3, 4), z = c(5, 6))
  ),
  combined = target(
    bind_rows(data, .id = "id") %>%
      arrange(sd) %>%
      head(n = 400),
    transform = combine(data, .by = c(x, y))
  )
)

drake_plan_source(plan)
```

In your post-processing, you may need the values of `x` and `y` that underly `data_1_3` and `data_2_4`. Solution: get the trace and the target names. We define a new plan

```{r}
plan <- drake_plan(
  data = target(
    sim_data(mean = x, sd = y),
    transform = map(x = c(1, 2), y = c(3, 4))
  ),
  larger = target(
    post_process(data, plan = ignore(plan)) %>%
      arrange(sd) %>%
      head(n = 400),
    transform = combine(data)
  ),
  trace = TRUE
)

drake_plan_source(plan)
```

and a new function

```{r, eval = FALSE}
post_process <- function(..., plan) {
  args <- list(...)
  names(args) <- all.vars(substitute(list(...)))
  trace <- filter(plan, target %in% names(args))
  # Do post-processing with args and trace.
}
```

### Grouping variables

A grouping variable is an argument to `map()`, `cross()`, or `combine()` that identifies a sub-collection of target names. Grouping variables can be either literals or symbols. Symbols can be scalars or vectors, and you can pass them to transformations with or without argument names.

#### Literal arguments

When you pass a grouping variable of literals, you must use an explicit argument name. One does not simply write `map(c(1, 2))`.

```{r}
drake_plan(x = target(sqrt(y), transform = map(y = c(1, 2))))
```

And if you supply integer sequences the usual way, you may notice some rows are missing.

```{r}
drake_plan(x = target(sqrt(y), transform = map(y = 1:3)))
```

Tidy evaluation and `as.numeric()` make sure all the data points show up.

```{r}
y_vals <- as.numeric(1:3)
drake_plan(x = target(sqrt(y), transform = map(y = !!y_vals)))
```

Character vectors usually work without a hitch, and quotes are converted into dots to make valid target names.

```{r}
drake_plan(x = target(get_data(y), transform = map(y = c("a", "b", "c"))))
```

```{r}
y_vals <- letters
drake_plan(x = target(get_data(y), transform = map(y = !!y_vals)))
```

#### Named symbol arguments

Symbols passed with explicit argument names define new groupings of existing targets on the fly, and only the `map()` and `cross()` transformations can accept them this ways. To generate long symbol lists, use the `syms()` function from the `rlang` package. Remember to use the tidy evaluation operator `!!` inside the transformation.

```{r}
vals <- rlang::syms(letters)
drake_plan(x = target(get_data(y), transform = map(y = !!vals)))
```

The new groupings carry over to downstream targets by default, which you can see with `trace = TRUE`. Below, the rows for targets `w_x` and `w_y` have entries in the and `z` column.

```{r}
drake_plan(
  x = abs(mean(rnorm(10))),
  y = abs(mean(rnorm(100, 1))),
  z = target(sqrt(val), transform = map(val = c(x, y))),
  w = target(val + 1, transform = map(val)),
  trace = TRUE
)
```

However, this is *incorrect* because `w` does not depend on `z_x` or `z_y`. So for `w`, you should write `map(val = c(x, y))` instead of `map(val)` to tell `drake` to clear the trace. Then, you will see `NA`s in the `z` column for `w_x` and `w_y`, which is right and proper.

```{r}
drake_plan(
  x = abs(mean(rnorm(10))),
  y = abs(mean(rnorm(100, 1))),
  z = target(sqrt(val), transform = map(val = c(x, y))),
  w = target(val + 1, transform = map(val = c(x, y))),
  trace = TRUE
)
```

### Tags

Tags are special optional grouping variables. They are ignored while the transformation is happening and then added to the plan to help subsequent transformations. There are two types of tags:

1. In-tags, which contain the target name you start with, and
2. Out-tags, which contain the target names generated by the transformations.

```{r}
drake_plan(
  x = target(
    command,
    transform = map(y = c(1, 2), .tag_in = from, .tag_out = c(to, out))
  ),
  trace = TRUE
)
```

Subsequent transformations can use tags as grouping variables and add to existing tags.

```{r}
plan <- drake_plan(
  prep_work = do_prep_work(),
  local = target(
    get_local_data(n, prep_work),
    transform = map(n = c(1, 2), .tag_in = data_source, .tag_out = data)
  ),
  online = target(
    get_online_data(n, prep_work, port = "8080"),
    transform = map(n = c(1, 2), .tag_in = data_source, .tag_out = data)
  ),
  summary = target(
    summarize(bind_rows(data, .id = "data")),
    transform = combine(data, .by = data_source)
  ),
  munged = target(
    munge(bind_rows(data, .id = "data")),
    transform = combine(data, .by = n)
  )
)

plan

config <- drake_config(plan)
vis_drake_graph(config)
```

<br>

### Target names

All transformations have an optional `.id` argument to control the names of targets. Use it to select the grouping variables that go into the names, as well as the order they appear in the suffixes. 

```{r}
drake_plan(
  data = target(
    get_data(param1, param2),
    transform = map(
      param1 = c(123, 456),
      param2 = c(7, 9),
      param2 = c("abc", "xyz"),
      .id = param2
    )
  )
)
```

```{r}
drake_plan(
  data = target(
    get_data(param1, param2),
    transform = map(
      param1 = c(123, 456),
      param2 = c(7, 9),
      param2 = c("abc", "xyz"),
      .id = c(param2, param1)
    )
  )
)
```

```{r}
drake_plan(
  data = target(
    get_data(param1, param2),
    transform = map(
      param1 = c(123, 456),
      param2 = c(7, 9),
      param2 = c("abc", "xyz"),
      .id = c(param1, param2)
    )
  )
)
```

Set `.id` to `FALSE` to ignore the grouping variables altogether.

```{r}
drake_plan(
  data = target(
    get_data(param1, param2),
    transform = map(
      param1 = c(123, 456),
      param2 = c(7, 9),
      param2 = c("abc", "xyz"),
      .id = FALSE
    )
  )
)
```

Finally, `drake` supports a special `.id_chr` symbol in commands to let you refer to the name of the current target as a character string.

```{r}
as_chr <- function(x) {
  deparse(substitute(x))
}
plan <- drake_plan(
  data = target(
    get_data(param),
    transform = map(param = c(123, 456))
  ),
  keras_model = target(
    save_model_hdf5(fit_model(data), file_out(!!sprintf("%s.h5", .id_chr))),
    transform = map(data, .id = param)
  ),
  result = target(
    predict(load_model_hdf5(file_in(!!sprintf("%s.h5", as_chr(keras_model))))),
    transform = map(keras_model, .id = param)
  )
)

plan
```

```{r}
drake_plan_source(plan)
```
